'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _heap = require('mnemonist/heap');

var _heap2 = _interopRequireDefault(_heap);

var _descriptive = require('../stats/descriptive');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * Talisman structure/vp-tree
                                                                                                                                                           * ===========================
                                                                                                                                                           *
                                                                                                                                                           * Implementation of the Vantage Point Tree.
                                                                                                                                                           *
                                                                                                                                                           * [Reference]:
                                                                                                                                                           * https://en.wikipedia.org/wiki/Vantage-point_tree
                                                                                                                                                           *
                                                                                                                                                           * [Note]:
                                                                                                                                                           * This implementation does not randomly select a point.
                                                                                                                                                           */


// TODO: implement random for choice? or better, a function to choose

// NOTE: i => 2i + 1, 2i + 2
// NOTE: 2^k+1 - 1
// NOTE: k = log2(n + 1) - 1 (rounded up to the next integer)
// TODO: use Float64Array * 2 size [index of item, mu]

/**
 * Constants.
 */
var COMPARATOR = function COMPARATOR(a, b) {
  if (a.distance < b.distance) return 1;
  if (a.distance > b.distance) return -1;

  return 0;
};

/**
 * Functions use to iteratively build the tree.
 *
 * @param  {function} distance - Distance function to use.
 * @param  {array}    data     - Items to store.
 */
function makeTree(distance, data) {
  var root = {},
      stack = [[root, data]];

  while (stack.length) {
    var _stack$pop = stack.pop(),
        branch = _stack$pop[0],
        items = _stack$pop[1];

    branch.vantage = items.pop();

    if (!items.length) continue;

    var distances = new Array(items.length);

    for (var i = 0, l = items.length; i < l; i++) {
      var item = items[i];
      distances[i] = distance(branch.vantage, item);
    }

    branch.mu = (0, _descriptive.median)(distances);

    var left = [],
        right = [];

    for (var _i = 0, _l = items.length; _i < _l; _i++) {
      var d = distances[_i];

      if (d >= branch.mu) right.push(items[_i]);else left.push(items[_i]);
    }

    if (left.length) {
      branch.left = {};
      stack.push([branch.left, left]);
    }
    if (right.length) {
      branch.right = {};
      stack.push([branch.right, right]);
    }
  }

  return root;
}

/**
 * Vantage Point Tree class.
 *
 * @constructor
 * @param {function} distance - Distance function.
 * @param {array}    items    - Items to store.
 */

var VPTree = function () {
  function VPTree(distance, items) {
    _classCallCheck(this, VPTree);

    // Validation
    if (typeof distance !== 'function') throw new Error('talisman/structures/vp-tree.constructor: given distance is not a function.');

    if (!Array.isArray(items)) throw new Error('talisman/structures/vp-tree.constructor: invalid items. Should be an array.');

    // Properties
    this.distance = distance;
    this.root = makeTree(distance, items.slice());
  }

  /**
   * Method used to retrieve the k nearest neighbors of query.
   *
   * @param {number} k     - Number of neighbors.
   * @param {any}    query - Query.
   * @param {array}        - Found neighbors.
   */


  VPTree.prototype.nearestNeighbors = function nearestNeighbors(k, query) {
    var neighbors = new _heap2.default(COMPARATOR),
        queue = [this.root];

    var tau = Infinity;

    while (queue.length > 0) {
      var node = queue.pop();

      var d = this.distance(query, node.vantage);

      if (d < tau) {
        neighbors.push({ distance: d, item: node.vantage });

        // Trimming
        if (neighbors.size > k) neighbors.pop();

        // Adjusting tau
        tau = neighbors.peek().distance;
      }

      if (!node.left && !node.right) continue;

      if (d < node.mu) {
        if (d < node.mu + tau && node.left) queue.push(node.left);
        if (d >= node.mu - tau && node.right) queue.push(node.right);
      } else {
        if (d >= node.mu - tau && node.right) queue.push(node.right);
        if (d < node.mu + tau && node.left) queue.push(node.left);
      }
    }

    var result = new Array(neighbors.size);

    for (var i = neighbors.size - 1; i >= 0; i--) {
      result[i] = neighbors.pop();
    }return result;
  };

  /**
   * Method used to retrieve every neighbors in the given range for the
   * given query.
   *
   * @param {number} range - Range.
   * @param {any}    query - Query.
   * @param {array}        - Found neighbors.
   */


  VPTree.prototype.neighborsInRange = function neighborsInRange(range, query) {
    var neighbors = [],
        stack = [this.root];

    var tau = range;

    while (stack.length > 0) {
      var node = stack.pop();

      var d = this.distance(query, node.vantage);

      if (d <= tau) neighbors.push({ distance: d, item: node.vantage });

      if (!node.left && !node.right) continue;

      if (d < node.mu) {
        if (d < node.mu + tau && node.left) stack.push(node.left);
        if (d >= node.mu - tau && node.right) stack.push(node.right);
      } else {
        if (d >= node.mu - tau && node.right) stack.push(node.right);
        if (d < node.mu + tau && node.left) stack.push(node.left);
      }
    }

    return neighbors;
  };

  return VPTree;
}();

exports.default = VPTree;
module.exports = exports['default'];